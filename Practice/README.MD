На практике я пытался написать сеть, играющую в игру:
  Имеется число x. Необходимо монетами с номиналами nominals выполнить размен числа x максимально точно.
FristTask.py - в данном файле используется случайно выбранная на занятии формула подсчета вероятностного распределения p по номиналам,
то есть p[i] - это вероятность выбрать номинал nominals[i]. Для оценки ошибки loss было использованно среднеквадратичное отклонение от 
x - nominals. Результат обучения просто сортировал числа в порядке возрастания, если смотреть на 
конечное состояние p, которое почти не менялось от входных данных. Разве что номиналы, много большие входных x и ранный нулю имели наименьшие 
вероятности.
В итоге ошибка на больших числах падала, а на маленьких росла.
SecondTask.py - та же задача, но поменялся teach в Network. Теперь программа пытается довести значение x до нуля, а не просто вычитать одно значение nominals. Вычитается не один из nominals, а delta, получаемая из вероятностей и nominals. У этой вариации получается наоборот выделить минимальное число как самое выгодное для размена. Однако в этот раз номинал равный нулю оказывался наилучшим для размена.
