На практике я пытался написать сеть, играющую в игру:
  Имеется число x. Необходимо монетами с номиналами nominals выполнить размен числа x максимально точно.
FristTask.py - в данном файле используется случайно выбранная на занятии формула подсчета вероятностного распределения p по номиналам,
то есть p[i] - это вероятность выбрать номинал nominals[i]. Для оценки ошибки loss было использованно среднеквадратичное отклонение от 
x - nominals. Результат обучения просто сортировал числа в порядке возрастания, если смотреть на 
конечное состояние p, которое почти не менялось от входных данных. Разве что номиналы, много большие входных x и ранный нулю имели наименьшие 
вероятности.
В итоге ошибка на больших числах падала, а на маленьких росла.
Вывод: похоже FirstTask.py не может работать иначе, ведь функция потерь оценивает потери после первого размена как расстояние до нуля. Логично, что первое действие в большинстве случаев стоит делать наибольшим номиналом.
SecondTask.py - та же задача, но поменялся teach в Network. Теперь программа пытается довести значение x до нуля, а не просто вычитать одно значение nominals. Вычитается не один из nominals, а delta, получаемая из вероятностей и nominals. У этой вариации получается наоборот выделить минимальное число как самое выгодное для размена. Однако в этот раз номинал равный нулю оказывался наилучшим для размена.
Что важно. Почему-то FirstTask.py почти не меняет значения второго слоя, SecobnTask.py - менят, хоть и медленно. Нужно понять причину этого.
Вывод: похоже SecondTask.py не может работать иначе, ведь функция потерь оценивает потери после последнего размена как расстояние до нуля. Логично, что последнее действие в большинстве случаев стоит делать наименьшим номиналом.
Может стоит использовать relu? Ведь sigmoid предназначен для классификации.
